# NTrace-core 项目记忆文件
# 供 LLM 在后续会话中快速加载上下文，避免重复分析

## 项目概述
- **名称**: NextTrace (NTrace-core)
- **仓库**: github.com/nxtrace/NTrace-core
- **语言**: Go (go 1.25.4+)
- **模块路径**: github.com/nxtrace/NTrace-core
- **功能**: 开源可视化 traceroute 工具，支持 ICMP/TCP/UDP 探测，异步 Geo IP 查询，多平台交叉编译
- **入口**: main.go → cmd.Execute()

## 构建须知（重要）
- **必须使用** `-ldflags "-checklinkname=0"` 编译，因为 `trace/internal/icmp_darwin.go` 使用了 `//go:linkname` 引用 Go 内部未导出函数 `net.internetSocket` 和 `net.newIPConn`
- 本地构建命令: `go build -ldflags "-checklinkname=0" ./...`
- 交叉编译脚本: `.cross_compile.sh`，其中 `LD_BASE` 已包含 `-checklinkname=0`
- macOS 构建需要 CGO_ENABLED=1（依赖 libpcap），其他平台 CGO_ENABLED=0
- CI: `.github/workflows/build.yml`，tag push 触发 release
- 版本号通过 ldflags 注入到 `config/basic.go` 的 `Version`、`BuildDate`、`CommitID`

## 目录结构与职责

```
main.go              → 入口，调用 cmd.Execute()
cmd/cmd.go           → CLI 参数解析、printer 选择、调用 trace.Traceroute()（~728 行核心调度）
config/              → Version/BuildDate/CommitID 变量 + viper 配置
trace/
  trace.go           → 核心：Traceroute()、Result、Hop、异步 Geo 机制、fetchIPData()、MPLS 解析（~800 行）
  icmp_ipv4.go       → ICMP IPv4 tracer
  icmp_ipv6.go       → ICMP IPv6 tracer
  tcp_ipv4.go        → TCP IPv4 tracer
  tcp_ipv6.go        → TCP IPv6 tracer
  udp_ipv4.go        → UDP IPv4 tracer
  udp_ipv6.go        → UDP IPv6 tracer
  cache.go           → 探测缓存
  globalping.go      → GlobalPing 集成
  quic.go            → QUIC 探测
  temp_printer.go    → 内部简单 printer（调试用）
  internal/          → 平台相关的底层 socket 操作（icmp/tcp/udp × darwin/unix/windows）
                       ⚠ icmp_darwin.go 使用 go:linkname，需 -checklinkname=0
printer/
  basic.go           → Version/CopyRight/PrintTraceRouteNav + applyLangSetting()
  realtime_printer.go      → 默认实时 printer（最常用路径）
  realtime_printer_router.go → 带路由表的实时 printer
  classic_printer.go → 经典 traceroute 风格 printer
  easy.go            → 管道友好的原始输出 printer
  tableprinter.go    → 表格输出 printer
  printer.go         → HopPrinter（经典模式用）+ formatIpGeoData
ipgeo/
  ipgeo.go           → IPGeoData 结构体定义 + Source 类型
  ipfilter.go        → 本地快速 IP 过滤（私有地址等）
  leo.go/ipsb.go/... → 各 Geo 数据源实现
  tokens.go          → API token 管理
tracelog/log.go      → 同时输出到stdout和/tmp/trace.log的printer
reporter/reporter.go → Route-Path 功能（实验性）
server/              → HTTP/WebSocket 服务器模式
  server.go          → Gin 路由注册
  trace_handler.go   → traceroute API 处理（~588 行）
  mtr.go             → MTR 模式
  ws_handler.go      → WebSocket 处理
  cache_handler.go   → 缓存 API
  web/               → 前端静态文件
fast_trace/          → 快速多目标探测
tracemap/            → tracemap 可视化集成
wshandle/            → WebSocket 客户端
dn42/                → DN42 网络支持
util/                → 工具函数（DNS、延迟计算、环境变量等）
pow/                 → PoW 验证
assets/windivert/    → Windows WinDivert 支持
```

## 异步 Geo 查询机制（v1.5.0 后新增，核心变更）

### 流程
1. 各 tracer 收到 hop 响应后调用 `res.addWithGeoAsync()` 而非旧的同步 `fetchIPData()`
2. `addWithGeoAsync` 先设 `hop.Geo = pendingGeo()`（Source="pending"），将 hop 加入 Result
3. 启动 goroutine 异步执行 `fetchIPData()`，完成后通过 `updateHop()` 回填真实 Geo 数据
4. `PrintFunc` 在打印前调用 `res.waitGeo(ctx, ttl)` 等待该 TTL 的 Geo 完成（有超时）
5. `Traceroute()` 返回前通过 `geoWG.Wait()` 等待所有异步查询完成（30s 硬超时）

### 关键类型和常量
- `PendingGeoSource = "pending"` — 导出常量，printer 中用于判断是否跳过
- `timeoutGeoSource = "timeout"` — 内部常量
- `pendingGeo()` → 占位 IPGeoData
- `timeoutGeo()` → 超时回退（Country="网络故障"）
- `geoWG sync.WaitGroup` — 追踪所有异步 Geo goroutine
- `geoWait time.Duration` — 每个 TTL 的等待预算

### Geo nil 安全规则
所有 printer 在访问 `hop.Geo.*` 前必须检查 nil：
```go
if res.Hops[ttl][i].Geo == nil {
    res.Hops[ttl][i].Geo = &ipgeo.IPGeoData{}
}
```
已修复的文件：realtime_printer.go、realtime_printer_router.go、easy.go、tracelog/log.go、reporter/reporter.go、tableprinter.go
未来新增 printer 也要遵守此规则。

## Result.add() 审计机制
```
add(hop, attemptIdx, numMeasurements, maxAttempts) → (added bool, idx int)
```
- attemptIdx < N-1：无条件放行
- attemptIdx >= N-1：审计（前面有有效 hop / 当前有效 / 到达 maxAttempts 三选一放行）
- 放行后 tailDone[k]=true，后续一律忽略
- 返回 (true, idx) 表示已加入，供 addWithGeoAsync 启动异步查询

## Printer 选择逻辑（cmd/cmd.go）
```
默认         → printer.RealtimePrinter
-r/--router  → printer.RealtimePrinterWithRouter
-c/--classic → printer.ClassicPrinter
-raw         → printer.EasyPrinter
-o/--output  → tracelog.RealtimePrinter
-T/--table   → printer.TracerouteTablePrinter (AsyncPrinter)
--report     → reporter.New().Print()
```

## 数据源（ipgeo.Source）
- LeoMoeAPI (默认) / IP.SB / IPInfo / IPInsight / IPAPI.com / IP2Region (chunzhen) / IPInfo本地 / DN42

## 测试
- 测试文件分布在各包中，但多数测试被注释掉
- `go test` 会因 linkname 问题失败（linker 阶段），需要：
  `go test -ldflags "-checklinkname=0" ./包名/`
- 或只对不依赖 trace/internal 的包单独测试

## 平台特殊处理
- Darwin: CGO + libpcap，go:linkname hack
- Windows: TCP/UDP 与 ICMP sniff 模式依赖 WinDivert（assets/windivert/）；ICMP Socket 模式可不依赖 WinDivert
- util/pcap.go 仅在 Darwin 构建（`//go:build darwin`）
- Linux: 支持 raw socket 和 unprivileged ICMP
- trace/internal/ 下按平台分文件：`*_darwin.go`、`*_unix.go`、`*_windows.go`

## 常见陷阱
1. 修改 printer 时必须处理 `Geo == nil` 和 `Geo.Source == PendingGeoSource`
2. 构建必须加 `-checklinkname=0`
3. `Result.Hops` 通过 `sync.RWMutex` 保护，异步访问需加锁
4. `singleflight.Group`（ipGeoSF/rDNSSF）用于去重并发查询
5. `geoCache = sync.Map{}` 全局缓存 Geo 结果
6. `fetchIPData` 内部重试逻辑：2s→3s→4s→...→6s（上限），最多 min(numMeasurements-1, 5) 次

## 最近修复记录（2026-02-10，Windows 去除 Npcap 依赖）
1. trace/internal/icmp_windows.go: ICMP 监听从 PCAP 切换为 WinDivert sniff（`wd.FlagSniff|wd.FlagRecvOnly`）
2. trace/internal/tcp_windows.go: TCP/ICMP 监听从 PCAP 切换为 WinDivert sniff
3. trace/internal/udp_windows.go: UDP/ICMP 监听从 PCAP 切换为 WinDivert sniff
4. util/pcap.go: build tag 由 `darwin || (windows && amd64)` 改为 `darwin`，Windows 构建不再引入 pcap
5. Windows `--icmp-mode` 语义更新：`1=Socket`、`2=WinDivert`、`0=Auto`

## 最近修复记录（2026-02-08，v1.5.0 后发版前审查）
1. trace/trace.go: waitGeo context 取消时标记 timeout
2. trace/trace.go: Traceroute() 30s 超时后清理所有 pending geo（markAllPendingGeoTimeout）
3. trace/trace.go: geoWaitForMeasurements 移除不可达代码
4. printer/realtime_printer.go: 添加 Geo nil guard
5. printer/realtime_printer_router.go: 添加 Geo nil guard + 补充 applyLangSetting
6. printer/easy.go: 添加 Geo nil guard
7. tracelog/log.go: 添加 Geo nil guard
8. reporter/reporter.go: InitialBaseData 添加 Geo != nil 检查
9. printer/tableprinter.go: 修复 nil 检查顺序 + 移除冗余死代码
